#!___EXPECTPATH___ -f
#
# This Expect script was generated by autoexpect on Wed Jun 30 12:58:22 2021
# Expect and autoexpect were both written by Don Libes, NIST.
#
# Note that autoexpect does not guarantee a working script.  It
# necessarily has to guess about certain things.  Two reasons a script
# might fail are:
#
# 1) timing - A surprising number of programs (rn, ksh, zsh, telnet,
# etc.) and devices discard or ignore keystrokes that arrive "too
# quickly" after prompts.  If you find your new script hanging up at
# one spot, try adding a short sleep just before the previous send.
# Setting "force_conservative" to 1 (see below) makes Expect do this
# automatically - pausing briefly before sending each character.  This
# pacifies every program I know of.  The -c flag makes the script do
# this in the first place.  The -C flag allows you to define a
# character to toggle this mode off and on.

set force_conservative 0  ;# set to 1 to force conservative mode even if
			  ;# script wasn't run conservatively originally
if {$force_conservative} {
	set send_slow {1 .1}
	proc send {ignore arg} {
		sleep .1
		exp_send -s -- $arg
	}
}

#
# 2) differing output - Some programs produce different output each time
# they run.  The "date" command is an obvious example.  Another is
# ftp, if it produces throughput statistics at the end of a file
# transfer.  If this causes a problem, delete these patterns or replace
# them with wildcards.  An alternative is to use the -p flag (for
# "prompt") which makes Expect only look for the last line of output
# (i.e., the prompt).  The -P flag allows you to define a character to
# toggle this mode off and on.
#
# Read the man page for more info.
#
# -Don

set sponsorkey [lindex $argv 0]
set applicantkey [lindex $argv 1]

set timeout 20
set send_slow {1 .1}
spawn ___GPGPATH___ --verbose --homedir ___KEYRINGDIRPATH___ --yes --with-colons --fixed-list-mode --fingerprint --fingerprint --no-default-keyring --no-auto-key-locate --keyring ___KEYRINGDIRPATH___/pubpubring.gpg --secret-keyring ___KEYRINGDIRPATH___/pubsecring.gpg --trustdb-name ___KEYRINGDIRPATH___/pubtrustdb.gpg --local-user $sponsorkey --edit-key $applicantkey
match_max 100000
expect -re ".*gpg> "
sleep .1
send -s -- "revsig\r"
send_user "after sending revsig\n"
sleep .1
#expect -indices -re "(?:   signed by your key (.{16}) on ....-..-.. \\(non-exportable\\)\r\n)*\r\nCreate a revocation certificate for this signature\\? \\(y/N\\) "
expect -indices -re "(?:   signed by your key (.{16}) on ....-..-..( \\(non-exportable\\))?\r\n)*\r\nCreate a revocation certificate for this signature\\? \\(y/N\\) "
sleep .1
send_user "\nfound siglist prompt\n"
# https://stackoverflow.com/questions/52995797/expect-how-to-send-user-for-dynamic-variable
# looking for key ids in expect_out fails, except for the last one...
# so just examine each line to see what index the desired revsig
# is on.
send_user "expect_out(buffer): ($expect_out(buffer))\n"
set re_keyid "   signed by your \(?:key\) \(.{16}\) on ....-..-..\(?: \\(non-exportable\\)\)*"
set keyids [regexp -all -inline $re_keyid $expect_out(buffer)]
send_user "keyids: ($keyids)\n"
send_user "keyids size: [llength $keyids]\n"
set revkeyindex "notfound"
set index 0
foreach {matchstring keyid} $keyids {
  send_user "keyid: $keyid\n"
  send_user "\[string compare $keyid $sponsorkey\]: [string compare $keyid $sponsorkey]\n"
  if {0 == [string compare $keyid $sponsorkey]} {
    set revkeyindex $index
  }
  incr index
}
send_user "revkeyindex: $revkeyindex\n"
if {0 == [string compare $revkeyindex "notfound"]} {
  send_user "failed to find signature to revoke!\n"
  exit
}
# is the first key the sponsorkey?
# if so delete it at the first Create... prompt, even before we
# get into the loop.
set queryindex 0
send_user "queryindex: $queryindex, revkeyindex: $revkeyindex\n"
# bail out here, let even the first match go to the expect loop
# that didn't work.  I don't know how to not consume the
# first Create... prompt, so need to do the revoke here before the loop,
# if revkeyindex is 0.
if { 0 == [string compare "0" $revkeyindex] } {
    sleep .1
    incr queryindex
    send_user "revkeyindex is 0...\n"
    send -s -- "y\r"
  } else {
    incr queryindex
    send_user "did not match index\n"
    send -s -- "N\r"
    sleep .1
    expect -re "N\r\n"
    send_user "Saw N ($expect_out(buffer))\n"
    sleep .1
}
sleep .1
expect {
  #-re "You are about to revoke these signatures:\r\n.*\r\n.*signed by your key $sponsorkey on ....-..-.. .*\r\nReally create the revocation certificates\\? \\(y/N\\) "
  -re ".*\r\nReally create the revocation certificates\\? \\(y/N\\) "
  {
    # no more sigs, so  commit to it.
send -s -- "y\r"
expect -exact "y\r
Please select the reason for the revocation:\r
  0 = No reason specified\r
  4 = User ID is no longer valid\r
  Q = Cancel\r
Your decision? "
sleep .1
send -s -- "0\r"
expect -exact "0\r
Enter an optional description; end it with an empty line:\r
> "
sleep .1
send -s -- "\r"
expect -exact "\r
Reason for revocation: No reason specified\r
(No description given)\r
Is this okay? (y/N) "
sleep .1
send -s -- "y\r"
expect -re "y\r\ngpg: .* signature from: \"$sponsorkey .*>\"\r\n\r\n\r\ngpg> "
send_user "saw signature from: ($expect_out(buffer))\n"
# now clean and save
sleep .1
send -s -- "clean\r"
sleep .1
expect -re "clean\r\n(gpg: removing signature from key .{16} on user ID \".*>\": signature superseded\r\n)*User ID \".*>\": .* signature(s)* removed\r\n\r\n\r\ngpg> "
sleep .1
send_user "saw clean\n"
send -s -- "save\r"
expect eof
exit
incr queryindex
sleep .1
  }
  -re ".*Create a revocation certificate for this signature?.........*"
  {
    send_user "saw Create... prompt\n"
    send_user "($expect_out(buffer))\n"
    send_user "queryindex: $queryindex, revkeyindex: $revkeyindex\n"
    if {0 == [string compare $queryindex $revkeyindex]} {
      send_user "queryindex matched revkeyindex\n"
      sleep .1
      #exit
      incr queryindex
      send -s -- "y\r"
      exp_continue
    } else {
      send_user "did not match index\n"
      incr queryindex
      send -s -- "N\r"
      sleep .1
      expect -re "N\r\n"
      send_user "Saw N ($expect_out(buffer))\n"
      sleep .1
      exp_continue
    }
  }
}
sleep .1
expect -re "y\r\nYou are about to revoke these signatures:\r\n.*\r\n.*signed by your key $sponsorkey on ....-..-.. .*\r\nReally create the revocation certificates\\? \\(y/N\\) "
sleep .1
send_user "Really create prompt"
send -s -- "y\r"
expect -exact "y\r
Please select the reason for the revocation:\r
  0 = No reason specified\r
  4 = User ID is no longer valid\r
  Q = Cancel\r
Your decision? "
sleep .1
send -s -- "0\r"
expect -exact "0\r
Enter an optional description; end it with an empty line:\r
> "
sleep .1
send -s -- "\r"
expect -exact "\r
Reason for revocation: No reason specified\r
(No description given)\r
Is this okay? (y/N) "
sleep .1
send -s -- "y\r"
expect -re "y\r\ngpg: .* signature from: \"$sponsorkey .*>\"\r\n\r\n\r\ngpg> "
incr queryindex
send_user "saw signature from: ($expect_out(buffer))\n"
# now clean and save
sleep .1
send -s -- "clean\r"
expect -re "clean\r\n(gpg: removing signature from key $sponsorkey on user ID \".*>\": signature superseded\r\n)*User ID \".*>\": .* signature(s)* removed\r\n\r\n\r\ngpg> "
sleep .1
send_user "saw clean\n"
#exit
send -s -- "save\r"
expect eof
exit
